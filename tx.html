<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Texas Filing Flow</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Stable libs -->
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4/dist/js-yaml.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@9.4.3/dist/mermaid.min.js"></script>
  <style>
    body { font-family: Inter, Tahoma, Arial, sans-serif; margin:24px; background:#f5f6f8; color:#111827 }
    .wrap{max-width:1100px;margin:0 auto}
    h1{margin:0 0 8px;font-size:24px;font-weight:800}
    .sub{color:#6b7280;margin-bottom:16px}
    .bar{display:flex;gap:8px;align-items:center;margin:8px 0 16px}
    .btn{border:1px solid #e5e7eb;background:#fff;padding:8px 12px;border-radius:10px;cursor:pointer}
    .btn:hover{background:#f9fafb}
    #chart{background:#fff;border:1px solid #e5e7eb;border-radius:14px;padding:16px}
    #chart svg{width:100% !important;height:auto !important}
    pre{background:#f9fafb;border:1px solid #e5e7eb;border-radius:12px;padding:12px;overflow:auto;margin-top:12px}
    .legend{display:flex;gap:12px;align-items:center;margin:6px 0 14px;font-size:13px;color:#6b7280}
    .dot{width:10px;height:10px;border-radius:999px;display:inline-block;margin-right:6px;border:1px solid #e5e7eb}
    .lane1{background:#f8fafc}
    .lane2{background:#f9fafb}
  </style>
</head>
<body>
<div class="wrap">
  <h1 id="title">Texas Filing Flow</h1>
  <div class="sub">Source: <span id="src"></span></div>

  <div class="legend">
    <span><span class="dot lane1"></span>InsCipher Connect</span>
    <span><span class="dot lane2"></span>State Portal</span>
  </div>

  <div class="bar">
    <button id="btnRefresh" class="btn">Refresh</button>
    <button id="btnDownload" class="btn">Download SVG</button>
  </div>

  <div id="chart"><div id="m" class="mermaid">Loading…</div></div>

  <h3 style="margin:16px 0 6px">Mermaid source</h3>
  <pre id="mer"></pre>
</div>

<script>
(async function(){
  const qs = new URL(location.href).searchParams;
  const yamlUrl = qs.get("yaml") || "./states/TX.yaml";   // default to TX.yaml
  document.getElementById("src").textContent = yamlUrl;

  async function getYaml(url){
    const res = await fetch(url, { cache: "no-store" });
    if(!res.ok) throw new Error("Fetch failed " + res.status + " for " + url);
    const raw  = await res.text();
    return jsyaml.load(raw);
  }

  // “Dash style” labels that we know render well
  const esc = t => String(t||"")
    .replace(/\s*\(([^)]+)\)/g, " - $1")  // (foo) ->  - foo
    .replace(/\r?\n/g, " ")               // single line
    .replace(/\[/g,"(").replace(/\]/g,")")// avoid bracket collisions
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .trim();

  function inferLane(id){
    // If you add a State Portal lane later, this keeps older YAMLs working
    if (/^(open_connect|start_filing|fix_address|archive_receipt|download_policy|verify_)/.test(id)) return 'connect';
    return 'state_portal';
  }

  function buildMermaid(data){
    const steps = (data.steps || []).map(s => ({
      id: s.id,
      type: s.type || 'action',
      label: esc(s.label || s.id),
      next: s.next,
      yes_to: s.yes_to,
      no_to: s.no_to,
      lane: s.lane || s.lane_key || inferLane(s.id)
    }));

    // Lane titles (defaults if not provided)
    const laneMap = {};
    if (Array.isArray(data.lanes) && data.lanes.length){
      data.lanes.forEach(l => laneMap[l.key] = l.title || l.name || l.key);
    } else {
      laneMap.connect = 'InsCipher Connect';
      laneMap.state_portal = 'State Portal';
    }

    const lanesInOrder = Object.keys(laneMap);
    const extraLanes = [...new Set(steps.map(s=>s.lane))].filter(k => !lanesInOrder.includes(k));
    const allLanes = [...lanesInOrder, ...extraLanes];

    const L = [];
    L.push('flowchart TB'); // vertical layout

    // Lanes + nodes
    for (const lane of allLanes){
      const title = laneMap[lane] || lane;
      const laneSteps = steps.filter(s => s.lane === lane);
      if (!laneSteps.length) continue;

      const laneId = lane.toUpperCase();
      L.push(`  subgraph ${laneId}[${title}]`);
      laneSteps.forEach(s => {
        const node = s.type === 'decision' ? `${s.id}{${s.label}}` : `${s.id}[${s.label}]`;
        L.push(`    ${node}`);
      });
      L.push('  end');
      L.push('');
    }

    // Edges
    steps.forEach(s=>{
      if (s.type === 'decision') {
        if (s.yes_to) L.push(`  ${s.id} -- Yes --> ${s.yes_to}`);
        if (s.no_to)  L.push(`  ${s.id} -- No --> ${s.no_to}`);
      } else if (s.next) {
        L.push(`  ${s.id} --> ${s.next}`);
      }
    });

    // Styles: no lane outlines (stroke transparent), rounded nodes
    L.push(
      'style CONNECT fill:#f8fafc,stroke:transparent,stroke-width:0px',
      'style STATE_PORTAL fill:#f9fafb,stroke:transparent,stroke-width:0px',
      'classDef action fill:#ffffff,stroke:#4f46e5,stroke-width:1.4px,color:#111827,rx:8,ry:8',
      'classDef decision fill:#fff7ed,stroke:#f04f23,stroke-width:2px,color:#111827,rx:12,ry:12'
    );
    steps.forEach(s => L.push(`class ${s.id} ${s.type === 'decision' ? 'decision' : 'action'}`));

    return L.join("\n");
  }

  async function render(){
    try{
      const data = await getYaml(yamlUrl);
      document.getElementById("title").textContent = `${data.state || 'State'} Filing Flow`;

      const mer = buildMermaid(data);
      document.getElementById("mer").textContent = mer;

      const el = document.getElementById("m");
      el.textContent = mer;
      el.removeAttribute("data-processed");

      mermaid.initialize({ startOnLoad:false, theme:'default', flowchart:{ curve:'linear', htmlLabels:false } });
      mermaid.init(undefined, el);
    } catch(e){
      document.getElementById("m").textContent = "Error: " + (e?.message || e);
      console.error(e);
    }
  }

  function downloadSVG(){
    const svg = document.querySelector('#chart svg');
    if(!svg){ alert('No diagram yet. Click Refresh.'); return; }
    const blob = new Blob([svg.outerHTML], {type:'image/svg+xml'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = (document.getElementById('title').textContent || 'diagram').replace(/\s+/g,'_') + '.svg';
    a.click();
    URL.revokeObjectURL(a.href);
  }

  document.getElementById('btnRefresh').onclick = () => render();
  document.getElementById('btnDownload').onclick = () => downloadSVG();

  // Initial render
  render();
})();
</script>
</body>
</html>
