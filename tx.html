<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Texas Filing Flow — Portrait</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4/dist/js-yaml.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@9.4.3/dist/mermaid.min.js"></script>
  <style>
    body { font-family: Inter, Tahoma, Arial, sans-serif; margin:24px; background:#f5f6f8; color:#111827 }
    .wrap{max-width:720px;margin:0 auto}
    h1{margin:0 0 8px;font-size:24px;font-weight:800}
    .sub{color:#6b7280;margin-bottom:12px}
    .bar{display:flex;gap:8px;align-items:center;margin:8px 0 12px;flex-wrap:wrap}
    .btn{border:1px solid #e5e7eb;background:#fff;padding:8px 12px;border-radius:10px;cursor:pointer}
    .btn:hover{background:#f0f2f5}
    #chart-wrap{background:#fff;border:1px solid #e5e7eb;border-radius:14px;padding:12px}
    #chart svg{width:100% !important;height:auto !important}
    @media print {
      @page { size: A4 portrait; margin: 12mm; }
      body { background:#fff; margin:0 }
      .bar, .sub { display:none !important }
      .wrap { max-width: 700px }
      #chart-wrap { border:0; padding:0 }
    }
  </style>
</head>
<body>
<div class="wrap">
  <h1 id="title">Texas Filing Flow</h1>
  <div class="sub">Source: <span id="src"></span></div>

  <div class="bar">
    <button id="btnRefresh" class="btn">Refresh</button>
    <button id="btnPrint" class="btn">Print PDF</button>
  </div>

  <div id="chart-wrap">
    <div id="chart"><div id="m" class="mermaid">Loading…</div></div>
  </div>
</div>

<script>
(async function(){
  const qs = new URL(location.href).searchParams;
  const yamlUrl = qs.get("yaml") || "./states/TX.yaml";   // default to TX.yaml
  document.getElementById("src").textContent = yamlUrl;

  async function getYaml(url){
    const res = await fetch(url, { cache: "no-store" });
    if(!res.ok) throw new Error("Fetch failed " + res.status + " for " + url);
    const raw  = await res.text();
    return jsyaml.load(raw);
  }

  // wrap labels (use \n, no HTML)
  function wrapText(str, width){
    const words = String(str||'').split(/\s+/);
    let line = '', out = [];
    for (const w of words){
      if ((line + ' ' + w).trim().length > width){
        if (line) out.push(line.trim());
        line = w;
      } else {
        line = (line ? line + ' ' : '') + w;
      }
    }
    if (line) out.push(line.trim());
    return out.join('\\n');
  }

  const esc = t => {
    const dash = String(t||'').replace(/\s*\(([^)]+)\)/g, ' - $1');
    const wrapped = wrapText(dash, 28);
    return wrapped
      .replace(/\[/g,'(').replace(/\]/g,')')
      .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
      .trim();
  };

  function inferLaneById(id){
    if (/^(open_connect|start_filing|fix_address|archive_receipt|download_policy|verify_)/.test(id)) return 'connect';
    return 'state_portal';
  }

  function buildMermaid(data){
    const steps = (data.steps || []).map(s => ({
      id: s.id,
      type: s.type || 'action',
      label: esc(s.label || s.id),
      next: s.next,
      yes_to: s.yes_to,
      no_to: s.no_to,
      laneKey: s.lane || s.lane_key || inferLaneById(s.id)
    }));

    // Only include lanes that actually have steps
    const usedLaneKeys = [...new Set(steps.map(s=>s.laneKey))];
    // Optional: titles if present in YAML, otherwise blank (we'll hide headers anyway)
    const titleByKey = {};
    if (Array.isArray(data.lanes)) {
      data.lanes.forEach(l => { titleByKey[l.key] = l.title || ''; });
    }

    const L = [];
    L.push('flowchart TB'); // portrait direction

    const anchorIds = [];

    // lanes + nodes + invisible anchors; empty lane titles to hide headers
    for (const laneKey of usedLaneKeys){
      const laneSteps = steps.filter(s => s.laneKey === laneKey);
      if (!laneSteps.length) continue;

      const laneId = laneKey.toUpperCase();
      const anchorId = `${laneId}_ANCHOR`;
      anchorIds.push(anchorId);

      // Empty [] → no visible subgraph title
      L.push(`  subgraph ${laneId}[]`);
      L.push(`    direction TB`);
      L.push(`    ${anchorId}(( ))`);
      L.push(`    class ${anchorId} ghost`);

      laneSteps.forEach(s => {
        const node = s.type === 'decision' ? `${s.id}{${s.label}}` : `${s.id}[${s.label}]`;
        L.push(`    ${node}`);
      });
      L.push('  end');
      L.push('');
    }

    // edges between steps
    steps.forEach(s=>{
      if (s.type === 'decision') {
        if (s.yes_to) L.push(`  ${s.id} -- Yes --> ${s.yes_to}`);
        if (s.no_to)  L.push(`  ${s.id} -- No --> ${s.no_to}`);
      } else if (s.next) {
        L.push(`  ${s.id} --> ${s.next}`);
      }
    });

    // chain lane anchors to stack lanes vertically (A above B)
    if (anchorIds.length > 1){
      for (let i = 0; i < anchorIds.length - 1; i++){
        const A = anchorIds[i];
        const B = anchorIds[i+1];
        L.push(`  ${A} -.-> ${B}`);
      }
    }

    // styles: no lane outlines; rounded nodes; hide anchors
    L.push(
      'style CONNECT fill:#f8fafc,stroke:transparent,stroke-width:0px',
      'style STATE_PORTAL fill:#f9fafb,stroke:transparent,stroke-width:0px',
      'classDef action fill:#ffffff,stroke:#4f46e5,stroke-width:1.4px,color:#111827,rx:8,ry:8',
      'classDef decision fill:#fff7ed,stroke:#f04f23,stroke-width:2px,color:#111827,rx:12,ry:12',
      'classDef ghost fill:transparent,stroke:transparent'
    );

    steps.forEach(s => L.push(`class ${s.id} ${s.type === 'decision' ? 'decision' : 'action'}`));
    return L.join("\n");
  }

  async function render(){
    try{
      const data = await getYaml(yamlUrl);
      document.getElementById("title").textContent = `${data.state || 'State'} Filing Flow`;

      const mer = buildMermaid(data);

      const el = document.getElementById("m");
      el.textContent = mer;
      el.removeAttribute("data-processed");

      mermaid.initialize({
        startOnLoad:false,
        theme:'default',
        flowchart:{
          curve:'linear',
          htmlLabels:false,
          useMaxWidth:true,
          nodeSpacing: 40,
          rankSpacing: 60,
          padding: 8,
          ranker: 'tight-tree'
        }
      });
      mermaid.init(undefined, el);
    } catch(e){
      document.getElementById("m").textContent = "Error: " + (e?.message || e);
      console.error(e);
    }
  }

  document.getElementById('btnRefresh').onclick = () => render();
  document.getElementById('btnPrint').onclick = () => window.print();

  render();
})();
</script>
</body>
</html>
