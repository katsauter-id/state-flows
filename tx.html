<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Texas Filing Flow — Portrait</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Stable libs -->
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4/dist/js-yaml.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@9.4.3/dist/mermaid.min.js"></script>
  <style>
    body { font-family: Inter, Tahoma, Arial, sans-serif; margin:24px; background:#f5f6f8; color:#111827 }
    .wrap{max-width:720px;margin:0 auto} /* portrait-friendly width */
    h1{margin:0 0 8px;font-size:24px;font-weight:800}
    .sub{color:#6b7280;margin-bottom:12px}
    .legend{display:flex;gap:12px;align-items:center;margin:6px 0 12px;font-size:13px;color:#6b7280}
    .dot{width:10px;height:10px;border-radius:999px;display:inline-block;margin-right:6px;border:1px solid #e5e7eb}
    .lane1{background:#f8fafc}
    .lane2{background:#f9fafb}
    .bar{display:flex;gap:8px;align-items:center;margin:8px 0 12px;flex-wrap:wrap}
    .btn{border:1px solid #e5e7eb;background:#fff;padding:8px 12px;border-radius:10px;cursor:pointer}
    .btn:hover{background:#f0f2f5}
    #chart-wrap{background:#fff;border:1px solid #e5e7eb;border-radius:14px;padding:12px}
    #chart svg{width:100% !important;height:auto !important}
    pre{background:#f9fafb;border:1px solid #e5e7eb;border-radius:12px;padding:12px;overflow:auto;margin-top:12px}

    /* Print-friendly portrait */
    @media print {
      @page { size: A4 portrait; margin: 12mm; }
      body { background:#fff; margin:0 }
      #mer, .bar, .legend, .sub { display:none !important }
      .wrap { max-width: 700px }
      #chart-wrap { border:0; padding:0 }
    }
  </style>
</head>
<body>
<div class="wrap">
  <h1 id="title">Texas Filing Flow</h1>
  <div class="sub">Source: <span id="src"></span></div>

  <div class="legend">
    <span><span class="dot lane1"></span>InsCipher Connect</span>
    <span><span class="dot lane2"></span>State Portal</span>
  </div>

  <div class="bar">
    <button id="btnRefresh" class="btn">Refresh</button>
    <button id="btnPrint" class="btn">Print PDF</button>
    <button id="btnDownload" class="btn">Download SVG</button>
  </div>

  <div id="chart-wrap">
    <div id="chart"><div id="m" class="mermaid">Loading…</div></div>
  </div>

  <h3 style="margin:16px 0 6px">Mermaid source</h3>
  <pre id="mer"></pre>
</div>

<script>
(async function(){
  const qs = new URL(location.href).searchParams;
  const yamlUrl = qs.get("yaml") || "./states/TX.yaml";   // default to TX.yaml
  document.getElementById("src").textContent = yamlUrl;

  // fetch + parse YAML
  async function getYaml(url){
    const res = await fetch(url, { cache: "no-store" });
    if(!res.ok) throw new Error("Fetch failed " + res.status + " for " + url);
    const raw  = await res.text();
    return jsyaml.load(raw);
  }

  // wrap labels to keep nodes narrow (no HTML; \n only)
  function wrapText(str, width){
    const words = String(str||'').split(/\s+/);
    let line = '', out = [];
    for (const w of words){
      if ((line + ' ' + w).trim().length > width){
        if (line) out.push(line.trim());
        line = w;
      } else {
        line = (line ? line + ' ' : '') + w;
      }
    }
    if (line) out.push(line.trim());
    return out.join('\\n');
  }

  // Labels: convert ( ) → " - ", wrap ~28 chars, escape brackets/entities
  const esc = t => {
    const dash = String(t||'').replace(/\s*\(([^)]+)\)/g, ' - $1');
    const wrapped = wrapText(dash, 28);
    return wrapped
      .replace(/\[/g,'(').replace(/\]/g,')')
      .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
      .trim();
  };

  function inferLane(id){
    if (/^(open_connect|start_filing|fix_address|archive_receipt|download_policy|verify_)/.test(id)) return 'connect';
    return 'state_portal';
  }

  function buildMermaid(data){
    const steps = (data.steps || []).map(s => ({
      id: s.id,
      type: s.type || 'action',
      label: esc(s.label || s.id),
      next: s.next,
      yes_to: s.yes_to,
      no_to: s.no_to,
      lane: s.lane || s.lane_key || inferLane(s.id)
    }));

    // lane titles
    const laneMap = {};
    if (Array.isArray(data.lanes) && data.lanes.length){
      data.lanes.forEach(l => laneMap[l.key] = l.title || l.name || l.key);
    } else {
      laneMap.connect = 'InsCipher Connect';
      laneMap.state_portal = 'State Portal';
    }

    const lanesInOrder = Object.keys(laneMap);
    const extraLanes = [...new Set(steps.map(s=>s.lane))].filter(k => !lanesInOrder.includes(k));
    const allLanes = [...lanesInOrder, ...extraLanes];

    const L = [];
    L.push('flowchart TB'); // portrait direction

    const firstNodeByLane = {};
    const lastNodeByLane  = {};
    const anchorIds = [];

    // lanes + nodes + invisible anchors to force vertical stacking
    for (const lane of allLanes){
      const title = laneMap[lane] || lane;
      const laneSteps = steps.filter(s => s.lane === lane);
      if (!laneSteps.length) continue;

      const laneId = lane.toUpperCase();
      const anchorId = `${laneId}_ANCHOR`;
      anchorIds.push(anchorId);

      L.push(`  subgraph ${laneId}[${title}]`);
      L.push(`    ${anchorId}(( ))`);
      L.push(`    class ${anchorId} ghost`);

      laneSteps.forEach((s, idx) => {
        const node = s.type === 'decision' ? `${s.id}{${s.label}}` : `${s.id}[${s.label}]`;
        L.push(`    ${node}`);
        if (idx === 0) firstNodeByLane[laneId] = s.id;
        lastNodeByLane[laneId] = s.id;
      });
      L.push('  end');
      L.push('');
    }

    // edges between steps
    steps.forEach(s=>{
      if (s.type === 'decision') {
        if (s.yes_to) L.push(`  ${s.id} -- Yes --> ${s.yes_to}`);
        if (s.no_to)  L.push(`  ${s.id} -- No --> ${s.no_to}`);
      } else if (s.next) {
        L.push(`  ${s.id} --> ${s.next}`);
      }
    });

    // connect lane anchors to stack lanes vertically (A above B above C)
    if (anchorIds.length > 1){
      for (let i = 0; i < anchorIds.length - 1; i++){
        const A = anchorIds[i];
        const B = anchorIds[i+1];
        L.push(`  ${A} -.-> ${B}`);
      }
    }

    // styles: no lane outlines; rounded nodes; hide anchor nodes
    L.push(
      'style CONNECT fill:#f8fafc,stroke:transparent,stroke-width:0px',
      'style STATE_PORTAL fill:#f9fafb,stroke:transparent,stroke-width:0px',
      'classDef action fill:#ffffff,stroke:#4f46e5,stroke-width:1.4px,color:#111827,rx:8,ry:8',
      'classDef decision fill:#fff7ed,stroke:#f04f23,stroke-width:2px,color:#111827,rx:12,ry:12',
      'classDef ghost fill:transparent,stroke:transparent'
    );

    steps.forEach(s => L.push(`class ${s.id} ${s.type === 'decision' ? 'decision' : 'action'}`));
    return L.join("\n");
  }

  async function render(){
    try{
      const data = await getYaml(yamlUrl);
      document.getElementById("title").textContent = `${data.state || 'State'} Filing Flow`;

      const mer = buildMermaid(data);
      document.getElementById("mer").textContent = mer;

      const el = document.getElementById("m");
      el.textContent = mer;
      el.removeAttribute("data-processed");

      // portrait-friendly layout
      mermaid.initialize({
        startOnLoad:false,
        theme:'default',
        flowchart:{
          curve:'linear',
          htmlLabels:false,
          useMaxWidth:true,
          nodeSpacing: 40,
          rankSpacing: 60,
          padding: 8,
          ranker: 'tight-tree'   // force vertical stacking preference
        }
      });
      mermaid.init(undefined, el);
    } catch(e){
      document.getElementById("m").textContent = "Error: " + (e?.message || e);
      console.error(e);
    }
  }

  function downloadSVG(){
    const svg = document.querySelector('#chart-wrap svg, #chart svg');
    if(!svg){ alert('No diagram yet. Click Refresh.'); return; }
    const blob = new Blob([svg.outerHTML], {type:'image/svg+xml'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = (document.getElementById('title').textContent || 'diagram').replace(/\s+/g,'_') + '.svg';
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // buttons
  document.getElementById('btnRefresh').onclick = () => render();
  document.getElementById('btnDownload').onclick = () => downloadSVG();
  document.getElementById('btnPrint').onclick = () => window.print();

  // initial render
  render();
})();
</script>
</body>
</html>
