<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>State Flow</title>
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4/dist/js-yaml.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@9.4.3/dist/mermaid.min.js"></script>
  <style>
    body { font-family: Tahoma, Arial, sans-serif; margin: 16px; background: #fafafa }
    #chart .mermaid { white-space: pre }
    pre { background: #f6f6f6; padding: 10px; border-radius: 8px; overflow:auto }
    .wrap { max-width:1100px; margin:0 auto }
  </style>
</head>
<body>
<div class="wrap">
  <h1 id="title">State Flow</h1>
  <div>Source: <span id="src"></span></div>
  <div id="chart"><div id="m" class="mermaid">Loadingâ€¦</div></div>
  <h3>Mermaid source</h3>
  <pre id="mer"></pre>
</div>

<script>
(async function(){
  const qs = new URL(location.href).searchParams;
  const yamlUrl = qs.get("yaml") || "./states/TX.yaml";   // default to TX.yaml
  document.getElementById("src").textContent = yamlUrl;

  // Fetch + parse YAML
  const res = await fetch(yamlUrl, { cache: "no-store" });
  if(!res.ok){ document.getElementById("chart").textContent = "Fetch failed " + res.status; return; }
  const raw  = await res.text();
  const data = jsyaml.load(raw);

  const esc = t => String(t||"")
    .replace(/\s*\(([^)]+)\)/g, " - $1")  // (foo) ->  - foo
    .replace(/\r?\n/g, " ")               // single line
    .replace(/\[/g,"(").replace(/\]/g,")")// avoid bracket collisions
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .trim();

  // Build Mermaid with optional lanes (subgraphs).
  // If YAML has lanes: [{key: 'connect', title: 'InsCipher Connect'}, ...] we use those.
  // Otherwise, we infer lanes by id prefixes/known ids.
  const steps = (data.steps || []).map(s => ({
    id: s.id,
    type: s.type || 'action',
    label: esc(s.label || s.id),
    next: s.next,
    yes_to: s.yes_to,
    no_to: s.no_to,
    lane: s.lane || s.lane_key || inferLane(s.id)
  }));

  function inferLane(id){
    // Heuristic fallback so older YAMLs still render in lanes
    if (/^(open_connect|start_filing|fix_address|archive_receipt)/.test(id)) return 'connect';
    return 'state_portal';
  }

  const laneMap = {};
  // If lanes are provided in YAML, use them; else define our defaults
  if (Array.isArray(data.lanes) && data.lanes.length){
    data.lanes.forEach(l => laneMap[l.key] = l.title || l.name || l.key);
  } else {
    laneMap.connect = 'InsCipher Connect';
    laneMap.state_portal = 'State Portal';
  }

  // Group by lane in insertion order of laneMap keys, then any others
  const lanesInOrder = Object.keys(laneMap);
  const extraLanes = [...new Set(steps.map(s=>s.lane))].filter(k => !lanesInOrder.includes(k));
  const allLanes = [...lanesInOrder, ...extraLanes];

  const L = [];
  L.push('flowchart TB');

  // Lanes + nodes
  for (const lane of allLanes){
    const title = laneMap[lane] || lane;
    const laneSteps = steps.filter(s => s.lane === lane);
    if (!laneSteps.length) continue;

    const laneId = lane.toUpperCase();
    L.push(`  subgraph ${laneId}[${title}]`);
    laneSteps.forEach(s => {
      const node = s.type === 'decision' ? `${s.id}{${s.label}}` : `${s.id}[${s.label}]`;
      L.push(`    ${node}`);
    });
    L.push('  end');
    L.push('');
  }

  // Edges
  steps.forEach(s=>{
    if (s.type === 'decision') {
      if (s.yes_to) L.push(`  ${s.id} -- Yes --> ${s.yes_to}`);
      if (s.no_to)  L.push(`  ${s.id} -- No --> ${s.no_to}`);
    } else if (s.next) {
      L.push(`  ${s.id} --> ${s.next}`);
    }
  });

  // Simple styles (kept minimal to avoid parser quirks)
  L.push(
    'style CONNECT fill:#f8f9fa,stroke:#4f46e5,stroke-width:1.2px',
    'style STATE_PORTAL fill:#f8f9fa,stroke:#468c98,stroke-width:1.2px',
    'classDef action fill:#ffffff,stroke:#4f46e5,stroke-width:1.2px,color:#111827',
    'classDef decision fill:#fff7ed,stroke:#f04f23,stroke-width:2px,color:#111827'
  );
  steps.forEach(s => L.push(`class ${s.id} ${s.type === 'decision' ? 'decision' : 'action'}`));

  const mer = L.join("\n");
  document.getElementById("mer").textContent = mer;
  document.getElementById("title").textContent = `${data.state || 'State'} Filing Flow`;

  // Render (DOM-fed, straight lines)
  const el = document.getElementById("m");
  el.textContent = mer;
  el.removeAttribute("data-processed");
  mermaid.initialize({ startOnLoad:false, theme:'default', flowchart:{ curve:'linear', htmlLabels:false } });
  mermaid.init(undefined, el);
})();
</script>
</body>
</html>
